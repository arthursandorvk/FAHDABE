/*
  Include glib.h and pbc.h before including this file. Note that this
  file should be included at most once.
*/

#if defined (__cplusplus)
extern "C" {
#endif

/*
 * System public key.
 */
typedef struct bswabe_pub_s bswabe_pub_t;

//----------------------------------------------------------------------------------------------------------------

/*
 * System master secret key.
 */
typedef struct bswabe_msk_s bswabe_msk_t;

//----------------------------------------------------------------------------------------------------------------

/*
 * former scheme cp-abe private key.
 */
typedef struct bswabe_prv_s bswabe_prv_t;

//----------------------------------------------------------------------------------------------------------------

/*
 * former scheme cp-abe private attribute key part.
 */
typedef struct bswabe_prv_comp_t bswabe_prv_comp_t;

//----------------------------------------------------------------------------------------------------------------

/*
 * dummy attribute structure in FAHDABE
 */
typedef struct arsanvkabe_prv_comp_s arsanvkabe_prv_comp_t;

//-------------------------------------------------------------------------------------------------------------------------------------------


/*
 * user private key in fahdabe
 */
typedef struct arsanvkabe_prv_user_s arsanvkabe_prv_user_t;

//----------------------------------------------------------------------------------------------------------------

/*
 * Data Owner Privilege Key Component in fahdabe
 */
typedef struct arsanvkabe_prv_do_s arsanvkabe_prv_do_t;

//----------------------------------------------------------------------------------------------------------------

/*
 * Attribute Authority Secret key Component in fahdabe
 */
typedef struct arsanvkabe_AA_secret_key_s skAA_t;

//----------------------------------------------------------------------------------------------------------------

/*
 * Resource-Rich Device Component in fahdabe to aggregate all the Attribute 
 *  Authority Secret Key Components belonging to a specific data user (DU) (an array of skAA_t)
 */
typedef struct arsanvkabe_RRD_key_s arsanvkabe_RRD_key_t;

//----------------------------------------------------------------------------------------------------------------

/*
 * first stage ciphertext generated by Data Owner (DO) local encryption in fahdabe
 */
typedef struct arsanvkabe_cph_DO_s arsanvkabe_cph_DO_t;


/*
 * second stage ciphertext generated by Resource-Rich Device (RRD) remote encryption in fahdabe
 */
typedef struct arsanvkabe_cph_RRD_s arsanvkabe_cph_RRD_t;


//----------------------------------------------------------------------------------------------------------------

/*
 * masking factor epsilon used by the DO to hide policy attribute values
 */
typedef struct arsanvkabe_epsilon_s arsanvkabe_epsilon_t;

//-----------------------------------------------------------------------------------------------------------------


/*
 * user public subkey sent to the resource-rich device 
 * to realize partial decryption (by extension applying revocation updates) 
 */
typedef struct arsanvkabe_user_rrd_subkey_s user_RRD_t;

//----------------------------------------------------------------------------------------------------------------


/*
  A ciphertext. Note that this library only handles encrypting a
  single group element, so if you want to encrypt something bigger,
  you will have to use that group element as a symmetric key for
  hybrid encryption (which you do yourself).
*/
typedef struct bswabe_cph_s bswabe_cph_t;

//----------------------------------------------------------------------------------------------------------------


/*
 * Parameter sent by the DO to Data users to enforce user collusion resistance.
   This scheme assumes that each DO sends such parameter to each new user. One can
   also decide to send such parameter (g^{r+gamma}) to each AA directly so that they update AA secret
   keys to ensure collusion resistance.... Do you trust AAs to do so ? anyway without such
   parameter or if they chose a malformed parameter (parameter forging), users will not be able to decrypt => Users
   cannot infer the parameter r or the parameter gamma.
 */
typedef struct arsanvkabe_DO_DU_param_s DO_DU_t;

//----------------------------------------------------------------------------------------------------------------

/*
  Generate a public key and corresponding master secret key, and
  assign the *pub and *msk pointers to them. The space used may be
  later freed by calling bswabe_pub_free(*pub) and
  bswabe_msk_free(*msk).
*/
void bswabe_setup( bswabe_pub_t** pub, bswabe_msk_t** msk );

//----------------------------------------------------------------------------------------------------------------

/*
 *convert A string into its SHA256 hash value
 */
char* compute_String_sha256(char* s);

//----------------------------------------------------------------------------------------------------------------

/*
 * Computes the LTHash value of the first input as digest and the second input as string
 * It returns the char* expression of theresulting digest
 */
char* compute_Lthash_Digest_hidden_epsilon(char* input2);

//----------------------------------------------------------------------------------------------------------------

/*
 * Computes the LTHash value of a string input and returns the string expression of a vector (as returned by LTHash)
 */
char* compute_Lthash_return_string(char* input_string);

//---------------------------------------------------------------------------------------------------------------

/*
 * Computes the LTHash value of two input strings and returns a char*
 */
char* compute_Lthash_Add_inputs_return_string(char* input1, char* input2);

//----------------------------------------------------------------------------------------------------------------

/*
 * random oracles H1:{0,1}* --> G2; H0:{0,1}* --> Zp; H3:{0,1}* --> G1: assigns any string to an elliptic curve group element or a field element
 * depending on the initialization of the element_t variable
 */ 
void element_from_string( element_t h, char* s );

//----------------------------------------------------------------------------------------------------------------

/*
 *This function H3: GT ---> {0,1}^l takes a pairing in GT and returns a non-bijective string expression
 */
char* pairing_to_string(element_t GTpairing);

//----------------------------------------------------------------------------------------------------------------


/*
 *To allow Data users to hide their attributes prior to requesting attribute keys from AAs
 */
char** arsanvkabe_hide(bswabe_pub_t* pub, char** attributes);

//----------------------------------------------------------------------------------------------------------------


/*
  Generate a private key with the given set of attributes. The final
  argument should be a null terminated array of pointers to strings,
  one for each attribute.
*/
/*bswabe_prv_t* bswabe_keygen( bswabe_pub_t* pub,
                             bswabe_msk_t* msk,
                             char** attributes );*/

//----------------------------------------------------------------------------------------------------------------

/*
 *  Generate the private key D with the public key, the master key, the dummy attribute and the attribute masking factor epsilon 
 */
//arsanvkabe_prv_do_t* arsanvkabe_keygenDO( bswabe_pub_t* pub, bswabe_msk_t* msk, char** dummy_attributes, arsanvkabe_epsilon_t* do_epsilon );
arsanvkabe_prv_do_t* arsanvkabe_keygen1( bswabe_pub_t* pub, bswabe_msk_t* msk, char* user_gid, char** dummy_attributes, arsanvkabe_epsilon_t* do_epsilon );

//----------------------------------------------------------------------------------------------------------------

/*
 * Generate the first stage ciphertext
 * m is used as seed to generate the aes secret key
 */
arsanvkabe_cph_DO_t* arsanvkabe_encrypt1( bswabe_pub_t* pub, element_t m, char* policy, element_t  dummy_attribute_element);

//----------------------------------------------------------------------------------------------------------------

/*
 * Generate the first stage ciphertext by the resource-rich device (RRD)
 */
arsanvkabe_cph_RRD_t* arsanvkabe_encrypt2(bswabe_pub_t* pub, element_t m, arsanvkabe_cph_DO_t* cph_DO);

//----------------------------------------------------------------------------------------------------------------


/*
 * had a conflicting type issue so added the line below (this method exists in the original cp-abe)
 */
struct bswabe_policy_t* parse_policy_postfix( char* s );
// 

//----------------------------------------------------------------------------------------------------------------

/*
 * Generate Attribute Authority Secret Key Component given public key and a set of hidden attributes
 */
skAA_t* arsanvkabe_keygen2(bswabe_pub_t* pub, char** attributes, char* user_gid);

//----------------------------------------------------------------------------------------------------------------

/*
 * Fetch Attribute authorithy secret key from a file on the disk
 */
skAA_t* fetchSKAA(bswabe_pub_t* pub, char *file);

//----------------------------------------------------------------------------------------------------------------

/*
 * Generate the attribute masking factor epsilon string that will be used to enforce attribute hiding
 */
arsanvkabe_epsilon_t* arsanvkabe_keygen0( bswabe_pub_t* pub, char* epsilon_string_value);

//----------------------------------------------------------------------------------------------------------------

/*
 * Assemble the various AA keys into the rrd_key (resource-rich device Key). 
 * rrd_key combines the AA keys from all sollicited Attribute Authorities.
 * rrd_key will be used for outsourced decryption
 */
arsanvkabe_RRD_key_t* arsanvkabe_keygen3(bswabe_pub_t* pub, GArray *fileAAList, element_t du_blind);

//----------------------------------------------------------------------------------------------------------------

/*
 * Output complete user secret key by combining subkeys received from DO and rrd_key respectively
 */
arsanvkabe_prv_user_t* arsanvkabe_keygen4(bswabe_pub_t* pub);

//----------------------------------------------------------------------------------------------------------------

/* 
 * Concatenate two strings (perhaps no need after all)
 */
char* concatenate(char* attr, char* epsilon);
//------------------------------------------------------------------------------------------------------------------------------------------

/*
  Exactly what it seems.
*/
GByteArray* bswabe_pub_serialize( bswabe_pub_t* pub );

//----------------------------------------------------------------------------------------------------------------

GByteArray* bswabe_msk_serialize( bswabe_msk_t* msk );

//----------------------------------------------------------------------------------------------------------------

GByteArray* bswabe_prv_serialize( bswabe_prv_t* prv );

//----------------------------------------------------------------------------------------------------------------

GByteArray* bswabe_cph_serialize( bswabe_cph_t* cph );

//----------------------------------------------------------------------------------------------------------------

/*
 * To serialize the D secret Key Component
 */
GByteArray* arsanvkabe_prv_do_serialize(arsanvkabe_prv_do_t * prv ); 

//----------------------------------------------------------------------------------------------------------------

/*
 * To serialize the first stage ciphertext arsanvkabe_cph_DO_t ciphertext CT_DO into a GByteArray
 */
GByteArray* arsanvkabe_cph_DO_serialize(arsanvkabe_cph_DO_t* cph_DO );

//--------------------------------------------------------------------------------------------------------------------

/*
 * To unserialize the the first stage ciphertext arsanvkabe_cph_DO_t ciphertext CT_DO from a GByteArray
 */
arsanvkabe_cph_DO_t* arsanvkabe_cph_DO_unserialize(bswabe_pub_t* pub, GByteArray* b, int free );

//-------------------------------------------------------------------------------------------------------------------
/*
 * To serialize the second stage ciphertext arsanvkabe_cph_RRD_t ciphertext CT_RRD into a GBYteArray
 */
GByteArray* arsanvkabe_cph_RRD_serialize(arsanvkabe_cph_RRD_t* cph_RRD );

//-------------------------------------------------------------------------------------------------------------------

/*
 * To unserialize the DO epsilon structure from a GByteArray
 */
arsanvkabe_epsilon_t* arsanvkabe_do_epsilon_unserialize( bswabe_pub_t* pub, GByteArray* b, int free );

//-------------------------------------------------------------------------------------------------------------------

/*
 * To serialize the DO epsilon structure down to a GByteArray
 */
GByteArray* arsanvkabe_do_epsilon_serialize(arsanvkabe_epsilon_t* DO_epsilon);

//-------------------------------------------------------------------------------------------------------------------


/*
 * To unserialize the second stage ciphertext arsanvkabe_cph_RRD_t ciphertext CT_RRD from a GBYteArray
 */
arsanvkabe_cph_RRD_t* arsanvkabe_cph_RRD_unserialize(bswabe_pub_t* pub, GByteArray* b, int free );

//-------------------------------------------------------------------------------------------------------------------

/*
 * To realize (outsourced) partial decryption by the resource-rich device
 * DU_Out_key serves as a subkey of the user complete secret key that can be outsourced (without security concerns)
 * to realize partial decryption; DU_Out_key is generated by the Data user itself.
 * F and I serve as the result from the decryption operation: fahdabe does not use such result (digital envelop) because
 * the result returned by the implementation fails to match theorethical results (which are correct). decCT_RRD_result should return e(g1,g2)^{(r+gamma)*s1}
 * While in the original cp-abe, e(g1,g2)^{r.s1} was being returned: Is it some kind of bug in the original code ? needs further investigation. 
 * 
 * arsanvkabe_decryptCT_RRD performs some outsourced computations for decryption and returns a boolean and a decryption proof = {decCT_RRD_result, F, I and Z}. 
 *  We are able to compute e(g,g)^{(r+ gamma).s1} and safely recover the aes seed m only after policy evaluation
 */
int arsanvkabe_transform1( bswabe_pub_t* pub, user_RRD_t* DU_Out_key, arsanvkabe_cph_RRD_t* cph_rrd, element_t T, element_t I );


//----------------------------------------------------------------------------------------------------------------

/*
 * To serialize an Attribute Authority secret Key Component.
 */
GByteArray* arsanvkabe_prv_AA_serialize( skAA_t* prv ); 

//----------------------------------------------------------------------------------------------------------------

/*
 * To serialize the final user secret key
 */
GByteArray* arsanvkabe_prv_userSK_serialize(arsanvkabe_prv_user_t* prv );

//----------------------------------------------------------------------------------------------------------------

/*
 * To serialize DU_Out_key (struct arsanvkabe_rrd_key_s (User_RRD_t)), which is the user's public subkey, to a GByteArray
 */
GByteArray* arsanvkabe_User_RRD_subKey_serialize(user_RRD_t* DU_Out_key);

//----------------------------------------------------------------------------------------------------------------

/*
 * To unserialize the DU_Out_key (struct arsanvkabe_rrd_key_s (User_RRD_t)), which is the user's public subkey, from a GByteArray
 */
user_RRD_t* arsanvkabe_User_RRD_subKey_unserialize(bswabe_pub_t* pub, GByteArray* b, int free);

//----------------------------------------------------------------------------------------------------------------

// Declared in common.h and defined in common.c 

/*
 * To write a GByteArray into file on the disk
 */
void store_gbyte_array( GByteArray* b, const char *filename);
//

/*
 * To load a GByteArray from a file on the disk
 */
GByteArray *load_gbyte_array(const char *filename);

//----------------------------------------------------------------------------------------------------------------

/*
 * To serialize the RRD key
 */
GByteArray* arsanvkabe_prv_rrdKey_serialize(arsanvkabe_RRD_key_t* rrd_key); 

//----------------------------------------------------------------------------------------------------------------

arsanvkabe_RRD_key_t* arsanvkabe_prv_rrdKey_unserialize (bswabe_pub_t* pub, GByteArray* b, int free ); // to unserialize the RRD key

//----------------------------------------------------------------------------------------------------------------


/* -------------------------------------------------------------------
  Also exactly what it seems. If free is true, the GByteArray passed
  in will be free'd after it is read.
*-------------------------------------------------------------------/

/*
 * To unserialize the public key (public parameters) from a GByteArray
 */
bswabe_pub_t* bswabe_pub_unserialize( GByteArray* b, int free );

//----------------------------------------------------------------------------------------------------------------

/*
 * To unserialize the master key from a GByteArray
 */
bswabe_msk_t* bswabe_msk_unserialize( bswabe_pub_t* pub, GByteArray* b, int free );

//----------------------------------------------------------------------------------------------------------------

/*
 * To unserialize Attribute Authority secret Key Component from a GByteArray 
 */
skAA_t* arsanvkabe_prv_AA_unserialize( bswabe_pub_t* pub, GByteArray* b, int free );  

//----------------------------------------------------------------------------------------------------------------

/*
 * To unserialize the Data Owner Key of a Data uSer from a GByteArray
 */
arsanvkabe_prv_do_t* arsanvkabe_prv_do_unserialize( bswabe_pub_t* pub, GByteArray* b, int free ); 

//----------------------------------------------------------------------------------------------------------------

/*
 * To unserialize the complete data user secret key from a GByteArray
 */
arsanvkabe_prv_user_t* arsanvkabe_prv_user_unserialize( bswabe_pub_t* pub, GByteArray* b, int free ); // to unserialize the user secret key

//----------------------------------------------------------------------------------------------------------------

/*
 * Again, exactly what it seems: To free memory from variables in parameters
 */
void bswabe_pub_free( bswabe_pub_t* pub );

//----------------------------------------------------------------------------------------------------------------

void bswabe_msk_free( bswabe_msk_t* msk );

//----------------------------------------------------------------------------------------------------------------

void bswabe_prv_free( bswabe_prv_t* prv );

//----------------------------------------------------------------------------------------------------------------

void bswabe_cph_free( bswabe_cph_t* cph );

//----------------------------------------------------------------------------------------------------------------

/*
 * To free second stage ciphertext CT_RRD generated by the resource-rich device
 */
void arsanvkabe_cph_rrd_free( arsanvkabe_cph_RRD_t* cph );

//----------------------------------------------------------------------------------------------------------------

/*
 *to free the CT_DO
 */
void arsanvkabe_cph_do_free( arsanvkabe_cph_DO_t* cph );

//----------------------------------------------------------------------------------------------------------------

/*
 * To free the arsanvkabe_epsilon_t DO structure for the attribute masking factor
 */
//void arsanvkabe_epsilon_t_free( arsanvkabe_epsilon_t* do_epsilon );

//----------------------------------------------------------------------------------------------------------------

/* to free a dummy attribute struct variable arsanvkabe_prv_comp_t */
void arsanvkabe_prv_comp_t_free( arsanvkabe_prv_comp_t* dummy_attr );

//----------------------------------------------------------------------------------------------------------------

/* 
 * To free attribute authority secret key
 */
void skAA_t_free(skAA_t* AA_key);

//----------------------------------------------------------------------------------------------------------------

/* 
 *To free the resource-rich device key structure
 */
void arsanvkabe_RRD_key_t_free(arsanvkabe_RRD_key_t* rrd_key);

//----------------------------------------------------------------------------------------------------------------

/* to free the public user subkey */
void user_RRD_t_free(user_RRD_t* DU_Out_key);

//----------------------------------------------------------------------------------------------------------------

/* to free the complete user key */
void arsanvkabe_prv_user_t_free(arsanvkabe_prv_user_t* userSK);

//----------------------------------------------------------------------------------------------------------------

/* to free the DO key arsanvkabe_prv_do_t*/
void arsanvkabe_prv_do_t_free( arsanvkabe_prv_do_t* do_key );

//----------------------------------------------------------------------------------------------------------------

/*
 * To address an undefined mapping issue
 */
struct bswabe_policy_t* unserialize_policy( bswabe_pub_t* pub, GByteArray* b, int* offset );

//------------------------------------------------------------------------------------------------------------------

/*
 * To serialize the access policy
 */
void serialize_policy( GByteArray* b, struct bswabe_policy_t* p );
//------------------------------------------------------------------------------------------------------------------

/*
  Return a description of the last error that occured. Call this after
  bswabe_enc or bswabe_dec returns 0. The returned string does not
  need to be free'd.
*/
char* bswabe_error();



#if defined (__cplusplus)
} // extern "C"
#endif
