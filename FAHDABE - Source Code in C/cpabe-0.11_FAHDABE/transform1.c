#include <assert.h>
#include <string.h>
#include <unistd.h>
#include <glib.h>
#include <pbc.h>
#include <pbc_random.h>
#include <time.h>

#include "policy_lang.h"
#include "bswabe.h"
#include "common.h"
#include "transform1.h"


char* usage =
"Usage: cpabe-transform1 [OPTION ...] PUB_KEY DU_OUT_KEY_FILE CT_RRD_File RDD_DECRYPT_RESULT_FILE \n"
"\n"
"Decrypt RDD Ciphertext in CT_RRD_File, which was generated by the resource-rich device (RRD)\n"
", using the public user subkey DU_OUT_KEY and assuming public key PUB_KEY. \n"
"Results will be stored in RDD_DECRYPT_RESULT_FILE. \n"
" Since the name of CT_RRD_File is of format  input_file.ct_do.cpabe, the decrypted file will\n"
"be written as input_file.ct_do. Use of the -o option overrides this\n"
"behavior.\n"
"CT_RRD_File will be removed unless option -k is used. \n"
"\n"
"Mandatory arguments to long options are mandatory for short options too.\n\n"
" -h, --help               print this message\n\n"
" -v, --version            print version information\n\n"
" -k, --keep-input-file    don't delete original file\n\n"
" -o, --output FILE        write output to FILE\n\n"
" -d, --deterministic      use deterministic \"random\" numbers\n"
"                          (only for debugging)\n\n"
/* " -s, --no-opt-sat         pick an arbitrary way of satisfying the policy\n" */
/* "                          (only for performance comparison)\n\n" */
/* " -n, --naive-dec          use slower decryption algorithm\n" */
/* "                          (only for performance comparison)\n\n" */
/* " -f, --flatten            use slightly different decryption algorithm\n" */
/* "                          (may result in higher or lower performance)\n\n" */
/* " -r, --report-ops         report numbers of group operations\n" */
/* "                          (only for performance evaluation)\n\n" */
"";

char* pub_file = 0; /* file containing the public key */
int   keep = 1; /* whether to keep  the RRD input ciphertext */
char* DU_Out_key_file = 0; /* Data User public Subkey to help with outsourced decryption */
char* CT_RRD_file = 0; /* file containing the RRD ciphertext */
char* aes_CT_DO_return_file =0; /* Name of file to hold the aes encryption of DO ciphertext */
char* RDD_Decrypt_Result_File = 0; // "decryptNode_Result.arsanvkabe"; /* Name of file to host the RRD decryption results */
char* CT_DO_plaintext_file = 0; // Name of file containing the decrypted content of the DO ciphertext: it ends with .ct_do


/*  Global variable to hold the time start */ 
clock_t start=0;

/* time difference time_diff */
clock_t time_diff=0;
	

void
parse_args( int argc, char** argv )
{
	int i;

	for( i = 1; i < argc; i++ )
		if(      !strcmp(argv[i], "-h") || !strcmp(argv[i], "--help") )
		{
			printf("%s", usage);
			exit(0);
		}
		else if( !strcmp(argv[i], "-v") || !strcmp(argv[i], "--version") )
		{
			printf(CPABE_VERSION, "-decryptCT_RRD");
			exit(0);
		}
		else if( !strcmp(argv[i], "-k") || !strcmp(argv[i], "--keep-input-file") )
		{
			keep = 1;
		}
		else if( !strcmp(argv[i], "-o") || !strcmp(argv[i], "--output") )
		{
			if( ++i >= argc )
				die(usage);
			else
				aes_CT_DO_return_file = argv[i];
		}
		else if( !strcmp(argv[i], "-d") || !strcmp(argv[i], "--deterministic") )
		{
			pbc_random_set_deterministic(0);
		}
		else if( !pub_file )
		{
			pub_file = argv[i];
		}
		else if( !DU_Out_key_file )
		{
			DU_Out_key_file  = argv[i];
		}
		else if( !CT_RRD_file )
		{
			CT_RRD_file = argv[i];
		}
		else if( !RDD_Decrypt_Result_File )
		{
			RDD_Decrypt_Result_File = argv[i];
		}
		else
			die(usage);

	if( !pub_file || !DU_Out_key_file || !CT_RRD_file || !RDD_Decrypt_Result_File )
		die(usage);

	/* Filename for the decrypted content  of DO ciphertext */
	if( !CT_DO_plaintext_file )
	{
		if(  strlen(CT_RRD_file) > 12 && 
				!strcmp(CT_RRD_file + strlen(CT_RRD_file) - 12, ".ct_do.cpabe") )
			CT_DO_plaintext_file = g_strndup(CT_RRD_file, strlen(CT_RRD_file) - 6); /* removing .cpabe extension */
		else
			CT_DO_plaintext_file = strdup(CT_RRD_file);
	}
	
	if( keep && !strcmp(CT_RRD_file, CT_DO_plaintext_file) )
		die("\n cannot keep RRD ciphertext file when decrypting DO ciphertext file in place (try -o)! \n");

}


int main( int argc, char** argv )
{
	/* We start the timer */
	start = clock();
	
	bswabe_pub_t* pub; /* public key */

	user_RRD_t* DU_Out_key; /* public user subKey for outsourced operations */

	int file_len; /* file length of the GByteArray containing the unencrypted DO ciphertext */

	GByteArray* aes_ct_do_buf; /* hold deserialized content of AES encrypted DO ciphertext */
	GByteArray* ct_rrdStruct_rrd_element_gbytearray; /* hold deserialized content of AES decrypted RRD ciphertext */
	GByteArray* cph_rrd_buf; /* hold deserialized content of RRD ciphertext */
	arsanvkabe_cph_RRD_t* cph_rrd; /* RRD ciphertext structure */
	element_t T, I; /* T and I stand as Proof of RRD applied decryption, which opens doors for future verifiable applications */
	GByteArray* cph_do_buf; /* hold the decrypted version of the DO ciphertext ( first encryption stage result )*/


	parse_args(argc, argv);


	pub = bswabe_pub_unserialize(suck_file(pub_file), 1);

	/* Unserializing the public user subkey, which contains sort of publicly disclosable user key and user attribute parameters */
	GByteArray* DU_Out_key_GByteArray=0;
	DU_Out_key_GByteArray = g_byte_array_new();
	DU_Out_key_GByteArray = load_gbyte_array(DU_Out_key_file);
	DU_Out_key = arsanvkabe_User_RRD_subKey_unserialize(pub, DU_Out_key_GByteArray, 1); /* freeing DU_Out_key_GByteArray */


	/* Reading the RRD ciphertext (using BSWABE CP-ABE function read_cpabe_file of the cpabe-toolkit) */ 
	read_cpabe_file(CT_RRD_file, &cph_rrd_buf, &file_len, &aes_ct_do_buf);


	/* Extracting the RRD ciphertext */	
	cph_rrd = arsanvkabe_cph_RRD_unserialize(pub, cph_rrd_buf, 1); /* freeing cph_rrd_buf */

	
	/* Evaluating hidden attributes against hidden policy and computing RRD decryption output {T, I}. Such output 
		serves as proof that the RDD applied decryption was successful on access policy evaluation
		and upholds the design of features based on such verification */
	if (arsanvkabe_transform1( pub, DU_Out_key, cph_rrd, T, I) == 0)
	{
		die("%s", bswabe_error());
	}
	else
	{
		/* Decryption Succeeded*/

		/* Prepare the decryption result to be serialized */
		GByteArray* decryptRRD_result_gbytearray;
		decryptRRD_result_gbytearray = g_byte_array_new();
		/* serializing decryption result {T, I}, which we denote as decryption proof  */
		serialize_element(decryptRRD_result_gbytearray, T); 
		serialize_element(decryptRRD_result_gbytearray, I);

		/* Writing the decryption result/pr in the corresponding file on disk */
		store_gbyte_array( decryptRRD_result_gbytearray, RDD_Decrypt_Result_File );


		/* Recovering the DO ciphertext ( first stage ciphertext )*/
		cph_do_buf = aes_128_cbc_decrypt(aes_ct_do_buf, cph_rrd->cs_do); /* Recovering Aes decrypted DO ciphertext content */
		g_byte_array_set_size(cph_do_buf, file_len);

		/* Serializing the decrypted content of the DO ciphertext in the corresponding file on disk */
		store_gbyte_array(cph_do_buf, CT_DO_plaintext_file);


		/* freeing some memory space (linked to successful hidden policy evaluation ) */
		g_byte_array_free(decryptRRD_result_gbytearray, 1);
		g_byte_array_free(cph_do_buf, 1);

	}
	
	/* freeing some memory space */
	arsanvkabe_cph_rrd_free(cph_rrd);
	element_clear(T);
	element_clear(I);
	user_RRD_t_free(DU_Out_key);


	if( !keep )
		unlink( CT_RRD_file );

	
	/* Timing the experiment */
	time_diff = (clock() - start);
	
	/* clock drift report */
	printf("Time taken by cpabe-decryptCT_RRD %f ms (milliseconds)\n\n",((double) (time_diff*1000) / CLOCKS_PER_SEC));
	

	return 0;
}
